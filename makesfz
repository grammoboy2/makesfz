#!/bin/bash
#
# 'makesfz' by Dan MacDonald 2012, modified by RockHopper 2013
#
# By default, running 'makesfz' with no arguments creates individual .sfz files
# for every .wav file found in the current directory. Samples are mapped across the 
# entire keyboard with pitch_keycenter set to MIDI key C4 (middle C).
#
# Alternatively, running 'makesfz -s' creates a single .sfz file named after the
# current directory. Each .wav file found is mapped to its own MIDI key, by default
# starting at C4.
#
# For a full list of options, run 'makesfz -h'
#
# This script is public domain and provided 'as-is', without any express or implied 
# warranty. In no event will the authors be held liable for any damages arising from 
# the use of this software.


declare -ra ARGS=("$@")
declare -ri NUM_ARGS=$#

declare -ri KEY_MAX=127
declare -ri KEY_MIN=0
declare -ri VEL_MAX=127

declare -a instrumentNames
declare -ia instrNumLayers
declare -ia instrFilesIndex
declare -a sampleFilePaths
declare -a fileSearchPaths
declare -a dirSearchPaths

declare isKeySet=false
declare isSingleFile=false
declare isReverseSortOn=false

declare loopMode="no_loop"
declare fileType="wav"
declare sfzFileName="${PWD##*/}" # SFZ file name defaults to present working directory
declare layerMarker=""
declare randMarker=""

declare -i lochan=1
declare -i hichan=16
declare -i lokey=0
declare -i hikey=127
declare -i keycenter=60
declare -i key=60
declare -i returnVal=0


function showHelp() 
{
    cat << EOF

Usage: makesfz [OPTION]...

By default, running makesfz with no arguments creates individual
sfz files for every wav file found in the current directory.
Samples are mapped across the entire keyboard with pitch_keycenter
set to MIDI key C4 (middle C).
    
Options:
  -s, --single          Creates a single sfz file named after the
                        current directory. Each wav file found is
                        mapped to its own MIDI key (starting at C4
                        by default)
  -n, --name 'NAME'     Output file name; ignored unless used with 
                        -s option
      --lk=KEY,         Set lokey. KEY must be 0 - 127 or C-1 - G9
      --lokey=KEY       (# or b allowed). Ignored when used with
                        -s option
      --hk=KEY,         Set hikey. KEY must be 0 - 127 or C-1 - G9
      --hikey=KEY       (# or b allowed). Ignored when used with
                        -s option
      --kc=KEY,         Set pitch_keycenter. KEY must be 0 - 127
      --keycenter=KEY   or C-1 - G9 (# or b allowed). Ignored when
                        used with -s option
  -k, --key=KEY         Overrides --lk, --hk, and --kc, setting lokey,
                        hikey, and pitch_keycenter to KEY.
                        When used with -s option, each wav file is
                        mapped to its own MIDI key starting at KEY
  -1, --one-shot        Set loop_mode to one_shot
  -m, --midi=CHAN       Set midi channel. CHAN must be 1 - 16 or
                        all (default)
  -f, --format=FORMAT   Format of audio files to scan for:
                        wav (default), flac, or ogg
  -h, --help            Display this help and exit

EOF
}


function showInvalidKeyError() 
{
    echo "Key must be in the range C-1 to G9"
    exit 1
}


function checkKeyIsValid() 
{
    declare input=$1
    declare -i key=0

    # check if user input is a valid key name
    if [[ $input =~ ^[a-gA-G](#|b)?(-1|[0-9])$ ]]; then
        case "${input:0:1}" in
            [cC] )  key=0;;
            [dD] )  key=2;;
            [eE] )  key=4;;
            [fF] )  key=5;;
            [gG] )  key=7;;
            [aA] )  key=9;;
            [bB] )  key=11;;
        esac

        local let numChars=`expr length $input`
        local let i=0
        for ((i=1; i < numChars; i++)); do
            if [ "${input:$i:1}" == "#" ]; then
                (( key++ ))
            fi
            if [ "${input:$i:1}" == "b" ]; then
                (( key-- ))
            fi
            if [ "${input:$i:1}" == "-" ]; then
                (( key -= 24 ))
            fi
        done

        local let octave=${input:(-1)}
        (( key += 12 * (octave + 1) ))

        if [ $key -lt $KEY_MIN ] || [ $key -gt $KEY_MAX ]; then
            showInvalidKeyError
        fi

        returnVal=$key

    # check if user input is a valid key number
    elif [[ $input =~ ^([0-9]|[1-9][0-9]|1[0-2][0-9])$ ]]; then
        key=$input
        if [ $key -gt $KEY_MAX ]; then
            showInvalidKeyError
        fi
        returnVal=$key

    else
        showInvalidKeyError
    fi
}


function setLoKey() 
{
    checkKeyIsValid $1
    lokey=$returnVal
}


function setHiKey() 
{
    checkKeyIsValid $1
    hikey=$returnVal
}


function setKeyCenter() 
{
    checkKeyIsValid $1
    keycenter=$returnVal
}


function setKey() 
{
    checkKeyIsValid $1
    key=$returnVal
    isKeySet=true
}


function setMidiChan() 
{
    declare input=$1

    # check user input is valid (1 to 16)
    if [[ $input =~ ^([1-9]|1[0-6])$ ]]; then
        lochan=$input
        hichan=$input
    elif [[ $input =~ ^(all|ALL)$ ]]; then
        lochan=1
        hichan=16
    else
        echo "MIDI channel must be '1 - 16' or 'all'"
        exit 1
    fi
}


function setFileType() 
{
    declare input=$1

    # check if user input is a valid file type
    case "$input" in
        [wW][aA][vV] )      fileType="wav";;
        [fF][lL][aA][cC] )  fileType="flac";;
        [oO][gG][gG] )      fileType="ogg";;
        * )                 echo "Invalid input: $input. File type must be wav, flac, or ogg"; exit 1;;
    esac
}


function setLayerMarker()
{
    declare input=$1

    # check if user input is valid
    case "$input" in
        [dD][iI][rR][sS] )          layerMarker="dirs";;
        [dD] )                      layerMarker="dirs";;
        [pP][rR][eE][fF][iI][xX] )  layerMarker="prefix";;
        [pP] )                      layerMarker="prefix";;
        [sS][uU][fF][fF][iI][xX] )  layerMarker="suffix";;
        [sS] )                      layerMarker="suffix";;
        * )                         echo "Invalid input: $input. Layer marker must be dirs, prefix, or suffix (or d, p, or s)"; exit 1;;
    esac
}


function setSearchPaths()
{
    declare -i param=$1

    while (( param < NUM_ARGS )); do

        if [ -f "${ARGS[$param]}" ]; then
            fileSearchPaths+=("${ARGS[$param]}")
        elif [ -d "${ARGS[$param]}" ] && [ "${ARGS[$param]}" != "." ] && [ "${ARGS[$param]}" != "./" ]; then
            dirSearchPaths+=("${ARGS[$param]}")
        fi

        (( param++ ))
    done
}


function processArgs()
{
    declare -i i=0

    if (( NUM_ARGS > 0 )); then
        while (( i < NUM_ARGS )); do
            case ${ARGS[$i]} in
                -s )            isSingleFile=true; isKeySet=true;;
                --single )      isSingleFile=true; isKeySet=true;;
                -n )            (( i++ )); sfzFileName=${ARGS[$i]};;
                --name )        (( i++ )); sfzFileName=${ARGS[$i]};;
                --lk )          (( i++ )); setLoKey ${ARGS[$i]};;
                --lokey )       (( i++ )); setLoKey ${ARGS[$i]};;
                --hk )          (( i++ )); setHiKey ${ARGS[$i]};;
                --hikey )       (( i++ )); setHiKey ${ARGS[$i]};;
                --kc )          (( i++ )); setKeyCenter ${ARGS[$i]};;
                --keycenter )   (( i++ )); setKeyCenter ${ARGS[$i]};;
                -k )            (( i++ )); setKey ${ARGS[$i]};;
                --key )         (( i++ )); setKey ${ARGS[$i]};;
                -1 )            loopMode="one_shot";;
                --oneshot )     loopMode="one_shot";;
                -m )            (( i++ )); setMidiChan ${ARGS[$i]};;
                --midi )        (( i++ )); setMidiChan ${ARGS[$i]};;
                -f )            (( i++ )); setFileType ${ARGS[$i]};;
                --format )      (( i++ )); setFileType ${ARGS[$i]};;
                -r )            isReverseSortOn=true;;
                --reverse )     isReverseSortOn=true;;
                -L )            (( i++ )); setLayerMarker ${ARGS[$i]};;
                --layers )      (( i++ )); setLayerMarker ${ARGS[$i]};;
                -- )            (( i++ )); setSearchPaths $i; break;;
                -h )            showHelp; exit 0;;
                --help )        showHelp; exit 0;;
                * )             echo "Invalid option: ${ARGS[$i]}. See 'makesfz -h' for usage"; exit 1;;
            esac
            (( i++ ))
        done
    fi
}


# File names may contain any character except for "\0" and "/" so care needs to be taken
# to prevent file names containing spaces or new lines from being split


function getNumMatchingFiles()
{
    declare -a searchPaths=("$1")

    if [ "$1" == "." ] || [ "$1" == "./" ]; then
        searchPaths=("${fileSearchPaths[@]}")
    fi

    # RS (Record Separator) is set to "/" as "\0" would simply read the entire
    # input stream as one record. Setting FS (Field Separator) to "\0" is no good
    # as that would cause individual characters to be treated as fields

    find "${searchPaths[@]}" -maxdepth 1 -type f -iname "*.$fileType" -printf "%f/" | gawk '
    BEGIN { RS = "/" }  # RS - Record Separator
    END { print NR }    # NR - No. of Records'

    unset searchPaths
}


function getSortedFileNames()
{
    declare -a searchPaths=("$1")

    if [ "$1" == "." ] || [ "$1" == "./" ]; then
        searchPaths=("${fileSearchPaths[@]}")
    fi

    declare key1=""
    declare key2=""
    declare key3=""
    declare sortOrder=""

    # File names are sorted by leading digits, trailing digits, and by any characters in between.
    # The order of the sort keys is dependant on the "layer marker"

    if $isReverseSortOn; then
        sortOrder="r"
    fi

    case $layerMarker in
        dirs )      key1="2,2d";            key2="1,1n$sortOrder";  key3="3,3n$sortOrder";;
        prefix )    key1="2,2d";            key2="3,3n";            key3="1,1n$sortOrder";;
        suffix )    key1="2,2d";            key2="1,1n";            key3="3,3n$sortOrder";;
        * )         key1="2,2d$sortOrder";  key2="1,1n";            key3="3,3n";;
    esac

    # sort -z appends null terminator instead of a new line
    # GNU tr won't delete "\0" unless explicitly told to

    find "${searchPaths[@]}" -maxdepth 1 -type f -iname "*.$fileType" -printf "%f/" | gawk '
    BEGIN {
        RS = "/"
        IGNORECASE = 1
    }
    {
        delimFileName = gensub(/(^[0-9]*)(.*[^0-9])([0-9]*[.]'$fileType'$)/, "\\1/\\2/\\3", 1)
        printf("%s\0", delimFileName)
    }
    ' | sort -z -t/ ${key1:+-k "$key1"} ${key2:+-k "$key2"} ${key3:+-k "$key3"} | tr -d '/'

    unset searchPaths
}


function findFilesLayerMarkerDirs()
{
    # IFS (Internal Field Separator) is set to null for duration of read operation to prevent
    # file names containing spaces or new lines from being split

    # Find sub-directories containing audio files 
    for directory in "${dirSearchPaths[@]}"; do
        while IFS= read -r -d '' subDir; do
            numFiles=$( getNumMatchingFiles "$subDir" )

            if (( numFiles > 0 )); then
                if (( numFiles > VEL_MAX )); then
                    echo -e "Warning: Instruments can only have $VEL_MAX layers \n$numFiles matching files found in $subDir \nOnly the first $VEL_MAX will be included\n"
                    numFiles=$VEL_MAX
                fi
                instrumentNames+=("${subDir##*/}")
                instrNumLayers+=($numFiles)
                instrFilesIndex+=($filesIndex)
                (( filesIndex += numFiles ))

                # Find audio files in sub-directory
                layerNum=1
                while IFS= read -r -d '' fileName; do
                    if (( layerNum <= VEL_MAX )); then
                        subDir="${subDir#./}"
                        filePath="$subDir/$fileName"
                        sampleFilePaths+=("${filePath//'/'/\\}")
                        (( layerNum++ ))
                    fi
                done < <(getSortedFileNames "$subDir")
            fi
        done < <(find "$directory" -maxdepth 1 -type d ! -wholename "$directory" -print0 | sort -z)
    done

    # Find audio files not in sub-directories
    findFilesLayerMarkerNone
}


function findFilesLayerMarkerPrefix()
{
    declare -i instrID=-1
    declare -iA instrLayerCounters
    declare instrName=""

    for directory in "${dirSearchPaths[@]}"; do
        numFiles=$( getNumMatchingFiles "$directory" )

        if (( numFiles > 0 )); then
            while IFS= read -r -d '' fileName; do

                # Strip leading digits and file extension from file name
                instrName=$( printf '%s/' "${fileName%.*}" | gawk 'BEGIN { RS = "/" }
                {
                    instrName = gensub(/^[0-9]*([^0-9].*)$/, "\\1", 1)
                    printf("%s", instrName)
                }')

                # If file belongs to a new instrument rather than a layer of an existing instrument...
                if [ "${instrLayerCounters[$instrName]}" == "" ]; then
                    (( instrID++ ))
                    instrumentNames+=("$instrName")
                    instrFilesIndex+=($filesIndex)
                fi

                instrLayerCounters["$instrName"]+=1
                layerNum=${instrLayerCounters["$instrName"]}
                if (( layerNum <= VEL_MAX )); then
                    instrNumLayers[$instrID]=$layerNum

                    if [ "$directory" == "." ] || [ "$directory" == "./" ]; then
                        filePath="$fileName"
                    else
                        filePath="$directory/$fileName"
                    fi
                    sampleFilePaths+=("${filePath//'/'/\\}")
                    (( filesIndex++ ))
                else
                    echo -e "Warning: Instruments can only have $VEL_MAX layers \nInstrument \""$( formatInstrName "$instrName" )"\" already has $VEL_MAX layers \n$fileName will not be included\n"
                fi
            done < <(getSortedFileNames "$directory")
        fi
    done
}


function findFilesLayerMarkerSuffix()
{
    declare -i instrID=-1
    declare -iA instrLayerCounters
    declare instrName=""

    for directory in "${dirSearchPaths[@]}"; do
        numFiles=$( getNumMatchingFiles "$directory" )

        if (( numFiles > 0 )); then
            while IFS= read -r -d '' fileName; do

                # Strip trailing digits and file extension from file name
                instrName=$( printf '%s/' "${fileName%.*}" | gawk 'BEGIN { RS = "/" }
                {
                    instrName = gensub(/^(.*[^0-9])[0-9]*$/, "\\1", 1)
                    printf("%s", instrName)
                }')

                # If file belongs to a new instrument rather than a layer of an existing instrument...
                if [ "${instrLayerCounters[$instrName]}" == "" ]; then
                    (( instrID++ ))
                    instrumentNames+=("$instrName")
                    instrFilesIndex+=($filesIndex)
                fi

                instrLayerCounters["$instrName"]+=1
                layerNum=${instrLayerCounters["$instrName"]}
                if (( layerNum <= VEL_MAX )); then
                    instrNumLayers[$instrID]=$layerNum

                    if [ "$directory" == "." ] || [ "$directory" == "./" ]; then
                        filePath="$fileName"
                    else
                        filePath="$directory/$fileName"
                    fi
                    sampleFilePaths+=("${filePath//'/'/\\}")
                    (( filesIndex++ ))
                else
                    echo -e "Warning: Instruments can only have $VEL_MAX layers \nInstrument \""$( formatInstrName "$instrName" )"\" already has $VEL_MAX layers \n$fileName will not be included\n"
                fi
            done < <(getSortedFileNames "$directory")
        fi
    done
}


function findFilesLayerMarkerNone()
{
    for directory in "${dirSearchPaths[@]}"; do
        numFiles=$( getNumMatchingFiles "$directory" )

        if (( numFiles > 0 )); then
            while IFS= read -r -d '' fileName; do
                instrumentNames+=("${fileName%.*}")
                instrNumLayers+=(1)
                if [ "$directory" == "." ] || [ "$directory" == "./" ]; then
                    filePath="$fileName"
                else
                    filePath="$directory/$fileName"
                fi
                sampleFilePaths+=("${filePath//'/'/\\}")
                instrFilesIndex+=($filesIndex)
                (( filesIndex++ ))
            done < <(getSortedFileNames "$directory")
        fi
    done
}


function formatInstrName()
{
    # Replace underscores with spaces and trim leading and trailing white space
    printf '%s' "$1" | tr '_' ' ' | xargs
}


function formatInstrNames()
{
    declare -ri numInstruments=${#instrumentNames[@]}
    declare -i instrID=0

    for (( instrID=0; instrID < numInstruments; instrID++ )); do
        instrumentNames[$instrID]=$( formatInstrName "${instrumentNames[$instrID]}" )
    done
}


function findFiles()
{
    declare -i numFiles=0
    declare -i filesIndex=0
    declare -i layerNum=0
    declare filePath=""

    # If both file and dir names have been passed on the command line then add PWD to dir search paths
    if (( ${#fileSearchPaths[@]} > 0 )) && (( ${#dirSearchPaths[@]} > 0 )); then
        dirSearchPaths+=(".")
    fi

    # If no file names have been passed on the command line then set file search path to PWD
    if (( ${#fileSearchPaths[@]} == 0 )); then
        fileSearchPaths=(".")
    fi

    # If no dir names have been passed on the command line then set dir search path to PWD
    if (( ${#dirSearchPaths[@]} == 0 )); then
        dirSearchPaths=(".")
    fi

    case $layerMarker in
        dirs )      findFilesLayerMarkerDirs;;
        prefix )    findFilesLayerMarkerPrefix;;
        suffix )    findFilesLayerMarkerSuffix;;
        * )         findFilesLayerMarkerNone;;
    esac

    formatInstrNames
}


function addGroup() 
{
    (( velIncrement = VEL_MAX / numLayers + 1 ))
    (( numBigIncrements = VEL_MAX % numLayers ))

    if (( numLayers == VEL_MAX )); then
        velIncrement=1
    fi
    lovel=1
    hivel=$velIncrement
    layerNum=1

    textLines+=("// $instrName")
    if $isKeySet; then
        textLines+=("<group> key=$key loop_mode=$loopMode lochan=$lochan hichan=$hichan")
    else
        textLines+=("<group> lokey=$lokey hikey=$hikey pitch_keycenter=$keycenter loop_mode=$loopMode lochan=$lochan hichan=$hichan")
    fi

    while (( fileID < filesIndex + numLayers )); do
        if (( lovel > 127 )); then
            lovel=127
        fi
        if (( hivel > 127 )); then
            hivel=127
        fi

        textLines+=("<region> lovel=$lovel hivel=$hivel sample=${sampleFilePaths[$fileID]}")

        if (( layerNum == numBigIncrements )); then
            (( velIncrement -= 1 ))
        fi
        (( lovel = hivel + 1 ))
        (( hivel += velIncrement ))

        (( layerNum++ ))
        (( fileID++ ))
    done

    textLines+=("")
}


function createSingleSfzFile()
{
    declare -a textLines
    declare -ri numInstruments=${#instrumentNames[@]}
    declare -i instrID=0
    declare instrName=""
    declare -i numLayers=0
    declare -i layerNum=0
    declare -i fileID=0
    declare -i filesIndex=0
    declare -i lovel=0
    declare -i hivel=0
    declare -i velIncrement=0
    declare -i numBigIncrements=0

    textLines+=("# This file was auto-generated by makesfz")
    textLines+=("")

    for (( instrID=0; instrID < numInstruments; instrID++ )); do
        if (( key > KEY_MAX )); then
            echo "Ran out of keys! Try assigning first sample to a lower key"
            exit 1
        fi
        instrName="${instrumentNames[$instrID]}"
        numLayers=${instrNumLayers[$instrID]}
        filesIndex=${instrFilesIndex[$instrID]}
        fileID=$filesIndex
        addGroup
        (( key++ ))
    done

    if [ -f "$sfzFileName".sfz ]; then
        echo -e "Warning: A file with the name $sfzFileName.sfz already exists \nDo you want to overwrite it?"
        read -e input
        if [[ $input == [yY] ]] || [[ $input == [yY][eE][sS] ]]; then
            rm -f "$sfzFileName".sfz
        else
            echo "Bailing out!"
            exit 1
        fi
    fi

    touch "$sfzFileName".sfz

    for line in "${textLines[@]}"; do
        printf '%s\n' "$line" >> "$sfzFileName".sfz
    done
}


function createMultiSfzFiles()
{
    declare -a textLines
    declare -ri numInstruments=${#instrumentNames[@]}
    declare -i instrID=0
    declare instrName=""
    declare -i numLayers=0
    declare -i layerNum=0
    declare -i fileID=0
    declare -i filesIndex=0
    declare -i lovel=0
    declare -i hivel=0
    declare -i velIncrement=0
    declare -i numBigIncrements=0

    for (( instrID=0; instrID < numInstruments; instrID++ )); do
        unset textLines
        textLines+=("# This file was auto-generated by makesfz")
        textLines+=("")

        instrName="${instrumentNames[$instrID]}"
        numLayers=${instrNumLayers[$instrID]}
        filesIndex=${instrFilesIndex[$instrID]}
        fileID=$filesIndex
        addGroup

        if [ -f "$instrName".sfz ]; then
            echo -e "Warning: A file with the name $instrName.sfz already exists \nDo you want to overwrite it?"
            read -e input
            if [[ $input == [yY] ]] || [[ $input == [yY][eE][sS] ]]; then
                rm -f "$instrName".sfz
            else
                echo "Bailing out!"
                exit 1
            fi
        fi

        touch "$instrName".sfz

        for line in "${textLines[@]}"; do
            printf '%s\n' "$line" >> "$instrName".sfz
        done
    done
}


# Main body of script

processArgs

if (( lokey > hikey )); then
    echo "lokey can't be higher than hikey"
    exit 1
fi

findFiles

if [ ${#sampleFilePaths[@]} -eq 0 ]; then
    echo "No $fileType files found!"
    exit 1
fi

if $isSingleFile; then
    createSingleSfzFile
else
    createMultiSfzFiles
fi

